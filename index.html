<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D 手势交互粒子系统 - 高精度版</title>

  <!-- 引入 Tailwind CSS 用于现代 UI -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- 引入 Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <!-- 引入 MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #050505;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }

    /* 摄像头预览 */
    #input-video {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 160px;
      height: 120px;
      border-radius: 12px;
      transform: scaleX(-1);
      /* 镜像 */
      z-index: 10;
      opacity: 0.7;
      border: 2px solid rgba(255, 255, 255, 0.2);
      transition: opacity 0.3s;
    }

    #input-video:hover {
      opacity: 1;
    }

    /* UI 控制面板 */
    #ui-panel {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(20, 20, 20, 0.85);
      backdrop-filter: blur(12px);
      padding: 24px;
      border-radius: 20px;
      z-index: 20;
      border: 1px solid rgba(255, 255, 255, 0.08);
      color: white;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
      width: 300px;
      transition: transform 0.3s ease;
    }

    .control-group {
      margin-bottom: 20px;
    }

    .control-label {
      font-size: 0.85rem;
      color: #9ca3af;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
    }

    /* 自定义颜色选择器样式 */
    input[type="color"] {
      -webkit-appearance: none;
      border: none;
      width: 100%;
      height: 44px;
      border-radius: 10px;
      cursor: pointer;
      padding: 0;
      background: none;
    }

    input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
    }

    input[type="color"]::-webkit-color-swatch {
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
    }

    /* 状态指示器 */
    #status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: #ef4444;
      /* Red */
      margin-right: 8px;
      box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
      transition: all 0.3s ease;
    }

    .status-active {
      background-color: #22c55e !important;
      /* Green */
      box-shadow: 0 0 15px #22c55e !important;
    }

    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      transition: opacity 0.5s;
    }

    .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid #333;
      border-top: 4px solid #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .output_canvas {
      display: none;
    }
  </style>
</head>

<body>

  <!-- 加载遮罩 -->
  <div id="loading" class="loading-overlay">
    <div class="spinner"></div>
    <div class="text-white font-light tracking-widest text-lg">AI 神经中枢启动中...</div>
    <div class="text-gray-500 text-sm mt-3">首次加载可能需要 5-10 秒</div>
  </div>

  <!-- UI 面板 -->
  <div id="ui-panel">
    <div class="flex items-center justify-between mb-6 pb-4 border-b border-gray-700">
      <h1 class="text-lg font-bold tracking-wide text-white">粒子场控制器</h1>
      <div class="flex items-center bg-gray-900 px-3 py-1 rounded-full border border-gray-700">
        <div id="status-indicator"></div>
        <span id="status-text" class="text-xs font-mono text-gray-400">WAITING</span>
      </div>
    </div>

    <div class="control-group">
      <label class="control-label">
        <span>能量颜色</span>
        <span class="text-xs opacity-50">Color</span>
      </label>
      <input type="color" id="color-picker" value="#00ffff">
    </div>

    <div class="control-group">
      <label class="control-label">
        <span>扩散场强度</span>
        <span id="scale-value" class="font-mono text-blue-400">0%</span>
      </label>
      <div class="w-full bg-gray-800 h-2 rounded-full overflow-hidden relative">
        <div id="scale-bar"
          class="bg-gradient-to-r from-blue-600 to-cyan-400 h-full w-0 transition-all duration-75 shadow-[0_0_10px_rgba(34,211,238,0.5)]">
        </div>
      </div>
    </div>

    <div class="mt-8 pt-0">
      <button id="fullscreen-btn"
        class="w-full py-3 px-4 bg-white/5 hover:bg-white/10 text-white rounded-xl text-sm font-medium transition-all flex items-center justify-center gap-2 border border-white/10 hover:border-white/20 group">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-400 group-hover:text-white transition-colors"
          fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
            d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 4l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
        </svg>
        进入沉浸模式
      </button>
    </div>

    <div class="mt-6 p-3 bg-white/5 rounded-lg border border-white/5">
      <p class="text-[10px] text-gray-400 uppercase tracking-wider mb-2 font-bold">交互指令 / INSTRUCTIONS</p>
      <ul class="text-xs text-gray-300 space-y-2 font-light">
        <li class="flex items-start gap-2">
          <span class="text-blue-400">●</span>
          <span>双手张开：触发大范围爆炸扩散</span>
        </li>
        <li class="flex items-start gap-2">
          <span class="text-blue-400">●</span>
          <span>单手捏合：控制微调缩放</span>
        </li>
      </ul>
    </div>
  </div>

  <video id="input-video"></video>
  <div id="canvas-container"></div>

  <script>
    // --- 1. 配置参数 ---
    const config = {
      particleCount: 18000, // 增加粒子数量提升效果
      baseColor: 0x00ffff,
      baseRadius: 14,
      maxExpansion: 3.5, // 爆炸倍数
      lerpSpeed: 0.1,    // 正常跟随速度
      resetSpeed: 0.2    // 丢失追踪时的回弹速度（更快）
    };

    // --- 全局变量 ---
    let scene, camera, renderer;
    let particles, geometry, material;
    let positions, originalPositions;

    // 状态管理
    let isHandsDetected = false;
    let targetInteractionFactor = 0;
    let currentInteractionFactor = 0;
    let lastHandDetectionTime = 0; // 上次检测到手的时间戳

    const uiElements = {
      loading: document.getElementById('loading'),
      statusIndicator: document.getElementById('status-indicator'),
      statusText: document.getElementById('status-text'),
      scaleBar: document.getElementById('scale-bar'),
      scaleValue: document.getElementById('scale-value'),
      colorPicker: document.getElementById('color-picker'),
      fullscreenBtn: document.getElementById('fullscreen-btn')
    };

    // --- 2. Three.js 初始化 ---
    function initThreeJS() {
      const container = document.getElementById('canvas-container');

      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x050505, 0.025);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 50;

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 性能优化
      container.appendChild(renderer.domElement);

      createParticles();

      window.addEventListener('resize', onWindowResize, false);

      uiElements.colorPicker.addEventListener('input', (e) => {
        const color = new THREE.Color(e.target.value);
        // 渐变过渡颜色
        const initialColor = material.color.clone();
        const targetColor = new THREE.Color(e.target.value);

        // 简单的颜色动画逻辑可以放在 animate 中，这里直接设置
        material.color = targetColor;
      });

      uiElements.fullscreenBtn.addEventListener('click', toggleFullScreen);
    }

    function createParticles() {
      geometry = new THREE.BufferGeometry();
      positions = new Float32Array(config.particleCount * 3);
      originalPositions = new Float32Array(config.particleCount * 3);

      for (let i = 0; i < config.particleCount; i++) {
        // 改进的球体分布算法
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);

        // 加上一些随机的体积感
        const r = config.baseRadius * Math.cbrt(Math.random());

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.sin(phi) * Math.sin(theta);
        const z = r * Math.cos(phi);

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        originalPositions[i * 3] = x;
        originalPositions[i * 3 + 1] = y;
        originalPositions[i * 3 + 2] = z;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      material = new THREE.PointsMaterial({
        color: config.baseColor,
        size: 0.25,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true,
        depthWrite: false // 禁用深度写入以获得更好的发光叠加效果
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function toggleFullScreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
          console.warn(`全屏请求被拒绝: ${err.message}`);
          alert("当前环境不支持全屏，请在标准浏览器窗口中尝试。");
        });
      } else {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        }
      }
    }

    // --- 3. 核心动画循环 ---
    function animate() {
      requestAnimationFrame(animate);

      // 1. 状态监测与回弹逻辑
      // 如果超过 200ms 没有检测到手，强制归零
      if (Date.now() - lastHandDetectionTime > 200) {
        isHandsDetected = false;
        targetInteractionFactor = 0;
      }

      // 如果没有手，使用更快的 resetSpeed 回弹，否则使用平滑的 lerpSpeed
      const speed = isHandsDetected ? config.lerpSpeed : config.resetSpeed;
      currentInteractionFactor += (targetInteractionFactor - currentInteractionFactor) * speed;

      // 防止极小数值抖动
      if (Math.abs(currentInteractionFactor) < 0.001) currentInteractionFactor = 0;

      // 更新 UI
      const percent = Math.round(currentInteractionFactor * 100);
      uiElements.scaleBar.style.width = `${percent}%`;
      uiElements.scaleValue.innerText = `${percent}%`;

      // 2. 粒子物理计算
      const time = Date.now() * 0.0005;

      // 整体旋转：扩散时旋转变慢，收缩时旋转变快
      const rotationSpeed = 0.002 + (1 - currentInteractionFactor) * 0.003;
      particles.rotation.y += rotationSpeed;
      particles.rotation.z += rotationSpeed * 0.5;

      const positionsArray = geometry.attributes.position.array;

      // 预计算一些常量以优化性能
      const expansion = 1 + (currentInteractionFactor * config.maxExpansion);
      const scatterIntensity = currentInteractionFactor * 8.0; // 散射强度

      for (let i = 0; i < config.particleCount; i++) {
        const ix = i * 3;
        const iy = i * 3 + 1;
        const iz = i * 3 + 2;

        const ox = originalPositions[ix];
        const oy = originalPositions[iy];
        const oz = originalPositions[iz];

        // 基础呼吸噪点 (待机时也有微弱动态)
        const breath = Math.sin(time * 2 + ox * 0.1) * 0.3;

        // 扰动计算 (扩散时扰动更大)
        const noiseX = Math.sin(time * 3 + oy * 0.05) * (0.2 + scatterIntensity * 0.1);
        const noiseY = Math.cos(time * 2 + oz * 0.05) * (0.2 + scatterIntensity * 0.1);
        const noiseZ = Math.sin(time * 4 + ox * 0.05) * (0.2 + scatterIntensity * 0.1);

        // 最终位置 = 原始位置 * 膨胀系数 + 呼吸 + 噪点
        // 当 currentInteractionFactor 为 0 时，expansion 为 1，回到原位
        positionsArray[ix] = (ox * expansion) + breath + noiseX;
        positionsArray[iy] = (oy * expansion) + breath + noiseY;
        positionsArray[iz] = (oz * expansion) + breath + noiseZ;
      }

      geometry.attributes.position.needsUpdate = true;

      // 动态调整粒子大小：扩散时粒子稍微变大
      material.size = 0.25 + (currentInteractionFactor * 0.2);

      renderer.render(scene, camera);
    }

    // --- 4. 增强版 AI 手势处理 ---
    function onResults(results) {
      // 严格检查：必须有 landmarks 且数组长度大于 0
      if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
        handleNoHands();
        return;
      }

      // 更新最后检测时间
      lastHandDetectionTime = Date.now();
      isHandsDetected = true;

      // UI 更新
      uiElements.statusIndicator.classList.add('status-active');
      uiElements.statusText.innerText = `TRACKING: ${results.multiHandLandmarks.length} HAND(S)`;
      uiElements.statusText.classList.remove('text-gray-400');
      uiElements.statusText.classList.add('text-green-400');

      // --- 核心距离计算 ---
      if (results.multiHandLandmarks.length === 2) {
        // === 双手模式 ===
        const h1 = results.multiHandLandmarks[0][9]; // 手掌中心点
        const h2 = results.multiHandLandmarks[1][9];

        // 计算欧几里得距离
        const dist = Math.sqrt(Math.pow(h1.x - h2.x, 2) + Math.pow(h1.y - h2.y, 2));

        // 映射逻辑：通常双手距离在 0.15 (并拢) 到 0.8 (张开) 之间
        // 使用 clamp 确保数值在 0-1 之间
        targetInteractionFactor = mapAndClamp(dist, 0.15, 0.7);

      } else {
        // === 单手模式 ===
        const h = results.multiHandLandmarks[0];
        const thumb = h[4];
        const index = h[8];

        const dist = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));

        // 映射逻辑：单手捏合 0.02 到 0.25
        targetInteractionFactor = mapAndClamp(dist, 0.03, 0.25);
      }
    }

    function handleNoHands() {
      isHandsDetected = false;
      targetInteractionFactor = 0; // 强制归零

      // UI 更新
      uiElements.statusIndicator.classList.remove('status-active');
      uiElements.statusText.innerText = "WAITING FOR INPUT";
      uiElements.statusText.classList.remove('text-green-400');
      uiElements.statusText.classList.add('text-gray-400');
    }

    function mapAndClamp(value, min, max) {
      const t = (value - min) / (max - min);
      return Math.max(0, Math.min(1, t));
    }

    // --- 初始化 MediaPipe ---
    async function initMediaPipe() {
      const videoElement = document.getElementById('input-video');

      const hands = new Hands({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }
      });

      // 关键修复：提高置信度阈值，防止背景误识别
      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.8, // 提高到 0.8 (原 0.5)
        minTrackingConfidence: 0.8   // 提高到 0.8 (原 0.5)
      });

      hands.onResults(onResults);

      const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
          await hands.send({ image: videoElement });
        },
        width: 640,
        height: 480
      });

      try {
        await cameraUtils.start();
        uiElements.loading.style.opacity = 0;
        setTimeout(() => {
          uiElements.loading.style.display = 'none';
        }, 500);
      } catch (error) {
        console.error("Camera Error:", error);
        uiElements.loading.innerHTML = `<div class="text-red-500">无法访问摄像头<br><span class="text-xs text-gray-400">请检查权限</span></div>`;
      }
    }

    window.onload = () => {
      initThreeJS();
      initMediaPipe();
      animate();
    };

  </script>
</body>

</html>